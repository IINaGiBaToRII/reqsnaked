{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p> Reqsnaked is a blazing fast async/await HTTP client for Python written on Rust using reqwests.</p> <p>Features over known libraries</p> <ul> <li>Works 15% faster on avarage</li> <li>RAII approach without context managers</li> <li>Memory-efficient lazy JSON parser</li> <li>Fully-typed even being written on Rust</li> </ul> Example<pre><code>import asyncio\nimport datetime\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client(\n        user_agent=\"Reqsnaked/1.0\",\n        headers={\"X-Foo\": \"bar\"},\n        store_cookie=True\n    )\n    request = reqsnaked.Request(\n        \"POST\", \"https://httpbin.org/anything\",\n        multipart=reqsnaked.Multipart(\n            reqsnaked.Part(\n                \"foo\", b\"01010101\",\n                filename=\"foo.txt\",\n                mime=\"text/plain\"\n            )\n        ),\n        query={\"foo\": \"bar\"},\n        headers={\"X-Bar\": \"foo\"},\n        timeout=datetime.timedelta(seconds=30),\n    )\n    response = await client.send(request)\n    print(response.status)\n    data = await response.json()\n    data.show()\n\n\nasyncio.run(main())\n</code></pre> See output <p><pre><code>HTTPStatus.OK\n</code></pre> <pre><code>{\n\"args\": {\n\"foo\": \"bar\"\n},\n\"data\": \"\",\n\"files\": {\n\"foo\": \"01010101\"\n},\n\"form\": {},\n\"headers\": {\n\"Accept\": \"*/*\",\n\"Accept-Encoding\": \"gzip, br\",\n\"Content-Length\": \"246\",\n\"Content-Type\": \"multipart/form-data; boundary=b51b5995e7edbe79-344812e1e33d6359-a8af9edbb71931c1-07455a8c16bded56\",\n\"Host\": \"httpbin.org\",\n\"User-Agent\": \"Reqsnaked/1.0\",\n\"X-Amzn-Trace-Id\": \"Root=1-63fa122b-422e7ccd67b718eb517ffd67\",\n\"X-Bar\": \"foo\",\n\"X-Foo\": \"bar\"\n},\n\"json\": null,\n\"method\": \"POST\",\n\"origin\": \"185.97.201.3\",\n\"url\": \"https://httpbin.org/anything?foo=bar\"\n}\n</code></pre></p>"},{"location":"#installlation","title":"Installlation","text":"<p>Currently the library is not published to PyPI, so the only way to install it is from GitHub: <pre><code>python -m pip install -U https://github.com/deknowny/reqsnaked/archive/main.zip\n</code></pre></p>"},{"location":"contributing/","title":"For contributors","text":""},{"location":"contributing/#install-the-project-in-dev-mode","title":"Install the project in dev mode","text":"<ol> <li>Fork the repository</li> <li>Clone the repository</li> <li>Create a new branch</li> </ol> <p>Then do this:</p> Linux/UnixWindows <pre><code>$ python -m venv .venv\n$ .venv/bin/python -m pip install .[docs, tests]\n</code></pre> <pre><code>python -m venv .venv\n.venv/Scripts/activate.bat\npython -m pip install .[docs]\n</code></pre>"},{"location":"contributing/#do-some-changes","title":"Do some changes","text":"<p>Change files and commit them</p> <p>Tip</p> <p>You can create draft files that are not included to repository in <code>.draft/</code> directory</p>"},{"location":"contributing/#run-test","title":"Run test","text":"<p>To run tests locally use <code>pytest</code>: <pre><code>$ pytest\n</code></pre> To run tests in many platforms and python version, push your changes to the remote and check out GitHub Actions</p>"},{"location":"contributing/#send-a-pr","title":"Send a PR","text":"<p>You are amazing!</p>"},{"location":"support/","title":"Support us","text":"<p>You can support us for further developing with any cryptocurrencies</p> <ul> <li>Ethereum-like networks (eth, bsc...): <code>0x6f57BA894474B58F6413f8015b478EAE22444F10</code></li> <li>TRON: <code>TWroJYdesLt4LHak1LimZjba5owhU7qzg1</code></li> <li>Bitcoin: <code>bc1qtlurpqm2038d0cmj26a7nsxafxcfwjtpk7hr6z</code></li> </ul> <p>Follow us in social media to stay tuned!</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>This section familiarizes you with all library concepts. It uses https://httpbin.org/ service to demonstrate how applied changed are affeted to behaviour. All examples you find could be copy-pasted and run in your environment (sometimes same parts are ommited, but you can always find a full code in attached snippets).</p>"},{"location":"user-guide/#how-read-this-guide","title":"How read this guide?","text":"<p>To dive into <code>reqsnaked</code> the first time, reading Understand the basics firstly is recommend. Then the order will not be important.</p> <p>Note</p> <p>Currently the <code>reqsnaked</code> support only <code>async/await</code> style, for sync requests use Requests library.</p> <p>Tip</p> <p>If you know a <code>reqwest</code> feature that did not implemented by <code>reqsnaked</code>, a PR would be a pleasure.</p>"},{"location":"user-guide/auth/","title":"Authoraztion","text":""},{"location":"user-guide/auth/#basic-auth","title":"Basic auth","text":"<p>To add basic auth to your request, use <code>username=</code> and <code>password=</code> params:</p> <p><pre><code>client = reqsnaked.Client()\nrequest = reqsnaked.Request(\n    \"POST\", \"https://httpbin.org/anything\",\n    username=\"John\",\n    password=\"D000eee\"  # It could be optional\n)\nresponse = await client.send(request)\ndata = await response.json()\nprint(data.query(\"headers\", \"Authorization\"))\n</code></pre> <pre><code>Basic Sm9objpEMDAwZWVl\n</code></pre></p> Full code preview <pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"POST\", \"https://httpbin.org/anything\",\n        username=\"John\",\n        password=\"D000eee\"  # Could be optional\n    )\n    response = await client.send(request)\n    data = await response.json()\n    print(data.query(\"headers\", \"Authorization\"))\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/auth/#bearer-auth","title":"Bearer auth","text":"<p>To add bearer auth to your request, use <code>bearer=</code> param:</p> <p><pre><code>client = reqsnaked.Client()\nrequest = reqsnaked.Request(\n    \"POST\", \"https://httpbin.org/anything\",\n    bearer_auth=\"fizzbazzeggg\",\n)\nresponse = await client.send(request)\ndata = await response.json()\nprint(data.query(\"headers\", \"Authorization\"))\n</code></pre> <pre><code>Bearer fizzbazzeggg\n</code></pre></p> Full code preview <pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"POST\", \"https://httpbin.org/anything\",\n        bearer_auth=\"fizzbazzeggg\",\n    )\n    response = await client.send(request)\n    data = await response.json()\n    print(data.query(\"headers\", \"Authorization\"))\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/basics/","title":"Understand the basics","text":""},{"location":"user-guide/basics/#send-a-request","title":"Send a request","text":"<p>The first step to make any HTTP request is create <code>reqsnaked.Client</code> instance. It introduces an asynchronous method to send a <code>reqsnaked.Request</code> and enables some customization that shares across all requests. It keeps connection to hosts alive, so it's useful to create only one client.</p> <p>Client could be created with or without a running event loop instantly. As it does all asynchronoues HTTP libraries, client should be closed in async style after usage, but it's not required for <code>reqsnaked</code> because internally it uses RAII approach and connection will be closed automatically.</p> <p>A simple GET request<pre><code>import asyncio\n\nimport reqsnaked\n\n\n# Note that you should not close the connection\n# as it happends using RAII approach\nasync def main():\n    client  = reqsnaked.Client()\n    request = reqsnaked.Request(\"GET\", \"https://httpbin.org/anything\")\n    response = await client.send(request)\n    print(response.status.value)\n\n\nasyncio.run(main())\n</code></pre> <pre><code>200\n</code></pre></p>"},{"location":"user-guide/basics/#process-the-response","title":"Process the response","text":"<p>After recieving the response, body could be accessed in different ways, for example, as JSON. The client will not await the whole response to be written, so at this step only status code, HTTP version and headers can be access before the body actually will be read, that's why it's neccessary use another one <code>await</code>.</p> Get response body as JSON<pre><code>client  = reqsnaked.Client()\nrequest = reqsnaked.Request(\n    \"GET\", \"https://httpbin.org/anything\",\n    query={\"foo\": \"bar\"}  # (1)\n)\n# Await first part of the response\nresponse = await client.send(request)\n\n# Await body and try decode it as JSON\nbody = await response.json()\nbody.show(\"args\") # (2)\n</code></pre> <ol> <li>Query string are arguments passed after URL's path so actually URL transforms to this: <pre><code>https://httpbin.org/anything?foo=bar\n</code></pre> You can read more about how use query string in <code>reqsnaked</code> there.</li> <li>Httpbin's <code>/anything</code> endpoint returns everything we passed, so <code>.show(\"args\")</code> used to print <code>[\"args\"]</code> from the response body.</li> </ol> <pre><code>{\"foo\": \"bar\"}\n</code></pre> Full code preview <pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client  = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"GET\", \"https://httpbin.org/anything\",\n        query={\"foo\": \"bar\"}  # (1)\n    )\n    # Await first part of the response\n    response = await client.send(request)\n\n    # Await body and try decode it as JSON\n    body = await response.json()\n    body.show(\"args\")  # (2)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/basics/#read-more","title":"Read more","text":"<p>Now you can read more about <code>reqsnaked.Client</code>, <code>reqsnaked.Request</code> and <code>reqsnaked.Response</code> in other topics.</p>"},{"location":"user-guide/chunks/","title":"Chunks (streaming response)","text":"<p>Chunks is way to read response body partially without awaiting when the whole body will be sent. It's useful when response is large. Use this pattern to iterate over chunks</p> Get image by parts<pre><code>client = reqsnaked.Client()\nrequest = reqsnaked.Request(\n    \"GET\", \"https://httpbin.org/image/jpeg\",  # (1)\n)\nresponse = await client.send(request)\nstream = response.to_stream()\nwhile chunk := await stream.gnaw():\n    print(chunk)\n</code></pre> <ol> <li>This endpoint returns an image</li> </ol> <pre><code>&lt;reqsnaked.Bytes object at 0x7ff54823ffb0&gt;\n&lt;reqsnaked.Bytes object at 0x7ff54823f4f0&gt;\n&lt;reqsnaked.Bytes object at 0x7ff54823fcb0&gt;\n&lt;reqsnaked.Bytes object at 0x7ff54823ffb0&gt;\n&lt;reqsnaked.Bytes object at 0x7ff54823f4f0&gt;\n</code></pre> Full code preview <pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"GET\", \"https://httpbin.org/image/jpeg\",\n    )\n    response = await client.send(request)\n    stream = response.to_stream()\n    while chunk := await stream.gnaw():\n        print(chunk)\n\nasyncio.run(main())\n</code></pre> <p>Failure</p> <p>You cannot read from body when creating a streamer</p>"},{"location":"user-guide/cookies/","title":"Cookies","text":"<p>You can automatically store and reuse cookies you recieved in a response using <code>store_cookies=True</code> parameter in <code>Client</code>. It will keep them in a jar.</p> <pre><code>client = reqsnaked.Client(store_cookie=True)\n</code></pre> <p>Todo</p> <p>Cookies wrapper is not implement in a better way now, it comes later. Now you should pass cookies by string into <code>Cookie</code> header and read it using some kind of <code>http.cookiejar</code></p>"},{"location":"user-guide/form/","title":"Send <code>application/x-www-form-urlencoded</code>","text":"<p>Simply to add form to request, you need to pass a dict with params into <code>reqsnaked.Request</code> construction.</p> <pre><code>request = reqsnaked.Request(\n    \"POST\", \"https://httpbin.org/anything\",\n    form={\"foo\": \"bar\"}\n)\n</code></pre> Full code preview <p><pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"POST\", \"https://httpbin.org/anything\",\n        form={\"foo\": \"bar\"}\n    )\n    response = await client.send(request)\n    content = await response.json()\n    # httpbin returns form we passed in the response\n    content.show(\"form\")\n\n\nasyncio.run(main())\n</code></pre> <pre><code>{\"foo\": \"bar\"}\n</code></pre></p> <p>It supports a few standart python types so form like this: <pre><code>form={\n    \"array\": [\"bar\", -123, False],\n    \"nothing\": None,\n    \"float\": 6.332,\n    \"boolean\": True\n}\n</code></pre></p> <p>Will produce such form string <pre><code>nothing=null&amp;boolean=1&amp;array=bar&amp;array=-123&amp;array=0&amp;float=6.332\n</code></pre></p>"},{"location":"user-guide/headers/","title":"Headers","text":""},{"location":"user-guide/headers/#send-request-with-headers","title":"Send request with headers","text":"<p>Simply to add a header to request, you need to pass a dict with headers into <code>reqsnaked.Request</code> construction <pre><code>request = reqsnaked.Request(\n    \"GET\", \"https://httpbin.org/anything\",\n    headers={\"X-Foo\": \"bar\"}\n)\n</code></pre></p> Full code preview <pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"GET\", \"https://httpbin.org/anything\",\n        headers={\"X-Foo\": \"bar\"}\n    )\n    response = await client.send(request)\n    content = await response.json()\n    # httpbin returns headers we passed in the response\n    content.show(\"headers\")\n\n\nasyncio.run(main())\n</code></pre> <p>Whether all your requests use the same headers, they could be provided using preset in <code>reqsnaked.Client</code> <pre><code>client = reqsnaked.Client(headers={\"X-Foo\": \"Bar\"})\n</code></pre></p> Full code preview <pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client(headers={\"X-Foo\": \"Bar\"})\n    request = reqsnaked.Request(\"GET\", \"https://httpbin.org/anything\")\n    response = await client.send(request)\n    content = await response.json()\n    # httpbin returns headers we passed in the response\n    content.show(\"headers\")\n\n\nasyncio.run(main())\n</code></pre> <p>You can also specify <code>User-Agent</code> directly using <code>user_agent=</code> parameter <pre><code>client = reqsnaked.Client(user_agent={\"User-Agent\": \"Reqsnaked/0.1\"})\n</code></pre></p> <p>To setup same headers for any request, use <code>headers=</code> parameter. All headers you pased as default could be overwritten in a certain request.</p> <p><pre><code>client = reqsnaked.Client(headers={\"X-Foo\": \"Bar\"})\nrequest = reqsnaked.Request(\"GET\", \"https://httpbin.org/anything\")\nresponse = await client.send(request)\ncontent = await response.json()\n# httpbin returns headers we passed in the response\ncontent.show(\"headers\")\n</code></pre> <pre><code>{\n\"Accept\": \"*/*\",\n\"Accept-Encoding\": \"gzip, br\",\n\"Host\": \"httpbin.org\",\n\"X-Amzn-Trace-Id\": \"Root=1-63f9ddb5-2618225027ab4df5375f7843\",\n\"X-Foo\": \"Bar\"\n}\n</code></pre></p> Full code preview <pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client(headers={\"X-Foo\": \"Bar\"})\n    request = reqsnaked.Request(\"GET\", \"https://httpbin.org/anything\")\n    response = await client.send(request)\n    content = await response.json()\n    # httpbin returns headers we passed in the response\n    content.show(\"headers\")\n\n\nasyncio.run(main())\n</code></pre> <p>You can also specify <code>User-Agent</code> directly with <code>user_agent=</code> <pre><code>client = reqsnaked.Client(user_agent=\"Reqsnaked/0.1\")\n</code></pre></p>"},{"location":"user-guide/headers/#read-headers-from-response","title":"Read headers from response","text":"<p>To access response headers use <code>reqsnaked.Response.headers</code> property where values are always <code>bytes()</code> instance: <pre><code>response = await client.send(request)\ndate = response.headers[\"date\"]\n</code></pre></p> Full code preview <pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client(headers={\"X-Foo\": \"Bar\"})\n    request = reqsnaked.Request(\"GET\", \"https://httpbin.org/anything\")\n    response = await client.send(request)\n    date = response.headers[\"date\"]\n\n\nasyncio.run(main())\n</code></pre> <p>Headers are <code>reqsnaked.HeaderMap</code> object and can be accessed directly using <code>__getitem__</code> or through <code>.to_dict()</code> conversion:</p> <pre><code>response = await client.send(request)\nassert response.headers[\"date\"] == response.headers.to_dict()[\"date\"]\n</code></pre> Full code preview <pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client(headers={\"X-Foo\": \"Bar\"})\n    request = reqsnaked.Request(\"GET\", \"https://httpbin.org/anything\")\n    response = await client.send(request)\n    assert response.headers[\"date\"] == response.headers.to_dict()[\"date\"]\n\n\nasyncio.run(main())\n</code></pre> <p>Note</p> <p><code>__getitem__</code> approach supports case-insensetive access to headers. When <code>HeaderMap</code> converted to dict, all header names will be lowercased</p>"},{"location":"user-guide/json/","title":"JSONs","text":""},{"location":"user-guide/json/#send-applicationjson","title":"Send <code>application/json</code>","text":"<p>Simply to add json to request, you need to pass a dict with params into <code>reqsnaked.Request</code> construction.</p> <pre><code>request = reqsnaked.Request(\n    \"POST\", \"https://httpbin.org/anything\",\n    json={\"foo\": \"bar\"}\n)\n</code></pre> Full code preview <p><pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"POST\", \"https://httpbin.org/anything\",\n        json={\"foo\": \"bar\"}\n    )\n    response = await client.send(request)\n    content = await response.json()\n    # httpbin returns json we passed in the response\n    content.show(\"json\")\n\n\nasyncio.run(main())\n</code></pre> <pre><code>{\"foo\": \"bar\"}\n</code></pre></p> <p>It supports all python types that a normally could be dumped using built-in <code>json</code> module. So this argument <pre><code>json={\n    \"array\": [\"bar\", -123, False],\n    \"nothing\": None,\n    \"float\": 6.332,\n    \"boolean\": True\n}\n</code></pre></p> <p>will produce such JSON <pre><code>{\n\"array\": [\n\"bar\",\n-123,\nfalse\n],\n\"boolean\": true,\n\"float\": 6.332,\n\"nothing\": null\n}\n</code></pre></p>"},{"location":"user-guide/json/#read-json-from-body","title":"Read JSON from body","text":"<p>JSON could be both read and parse using <code>Response.json()</code> method. It returns a special <code>LazyJSON</code> object:</p> <p><pre><code>client = reqsnaked.Client()\nrequest = reqsnaked.Request(\n    \"POST\", \"https://httpbin.org/json\",\n)\nresponse = await client.send(request)\ndata = await response.json()\ndata.show()\n</code></pre> <pre><code>{\n\"slideshow\": {\n\"author\": \"Yours Truly\",\n\"date\": \"date of publication\",\n\"slides\": [\n{\n\"title\": \"Wake up to WonderWidgets!\",\n\"type\": \"all\"\n},\n{\n\"items\": [\n\"Why &lt;em&gt;WonderWidgets&lt;/em&gt; are great\",\n\"Who &lt;em&gt;buys&lt;/em&gt; WonderWidgets\"\n],\n\"title\": \"Overview\",\n\"type\": \"all\"\n}\n],\n\"title\": \"Sample Slide Show\"\n}\n}\n</code></pre></p> Full code preview <p><pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"POST\", \"https://httpbin.org/json\",\n    )\n    response = await client.send(request)\n    data = await response.json()\n    data.show()\n\n\nasyncio.run(main())\n</code></pre> <pre><code>{\"foo\": \"bar\"}\n</code></pre></p> <p>It's called \"lazy\" because it does not load everything into Python types immidiately. To access something use <code>.query(...)</code> method, which accepts <code>*args</code> that uses chainly to get an object:</p> <p><pre><code>client = reqsnaked.Client()\nrequest = reqsnaked.Request(\n    \"POST\", \"https://httpbin.org/json\",\n)\nresponse = await client.send(request)\ndata = await response.json()\nprint(data.query(\"slideshow\", \"slides\", 0, \"title\"))\n</code></pre> <pre><code>\"Wake up to WonderWidgets!\"\n</code></pre></p> Full code preview <p><pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"POST\", \"https://httpbin.org/json\",\n    )\n    response = await client.send(request)\n    data = await response.json()\n    print(data.query(\"slideshow\", \"slides\", 0, \"title\"))\n\n\nasyncio.run(main())\n</code></pre> <pre><code>{\"foo\": \"bar\"}\n</code></pre></p> <p>It's the same as you would use <code>data[\"slideshow\"][\"slides\"][0][\"title\"]</code> with an ordinary dict. In this case only string <code>\"Wake up to WonderWidgets!\"</code> will be loaded to python types, other will be stored using Rust cheap types.</p> <p>Tip</p> <p>The same \"chaining\" works for <code>.show(...)</code></p> <p>Failure</p> <p>You cannot read from body twice</p>"},{"location":"user-guide/multipart/","title":"Multipart","text":"<p>To send <code>multipart/form-data</code> request, pass an object to <code>multipart=</code> param</p> Send two files<pre><code>request = reqsnaked.Request(\n    \"POST\", \"https://httpbin.org/anything\",\n    multipart=reqsnaked.Multipart(\n        reqsnaked.Part(\n            \"foo\", b\"000\"\n            filename=\"foo.txt\",\n            mime=\"text/plain\"\n        ),\n        reqsnaked.Part(\n            \"bar\", b\"111\",\n            filename=\"bar.txt\",\n            mime=\"text/plain\"\n        )\n    ),\n)\n</code></pre> Full code preview <p><pre><code>import asyncio\n\nimport reqsnaked\n\nasync def main():\n    client = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"POST\", \"https://httpbin.org/anything\",\n        multipart=reqsnaked.Multipart(\n            reqsnaked.Part(\"foo\", b\"000\", filename=\"foo.txt\",\n                            mime=\"text/plain\"),\n            reqsnaked.Part(\"bar\", b\"111\", filename=\"bar.txt\",\n                        mime=\"text/plain\")\n        ),\n    )\n    response = await client.send(request)\n    content = await response.json()\n    # httpbin returns query string we passed in the response\n    content.show()\n\nasyncio.run(main())\n</code></pre> <pre><code>{\n\"bar\": \"111\",\n\"foo\": \"000\"\n}\n</code></pre></p> <p>Todo</p> <p>Currently, only raw bytes and strings are supported for content, <code>io</code> objects are coming soon</p>"},{"location":"user-guide/query-string/","title":"Send request with query string","text":"<p>Simply to add query params to request, you need to pass a dict with params into <code>reqsnaked.Request</code> construction.</p> <pre><code>request = reqsnaked.Request(\n    \"GET\", \"https://httpbin.org/anything\",\n    query={\"foo\": \"bar\"}\n)\n</code></pre> Full code preview <p><pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"GET\", \"https://httpbin.org/anything\",\n        query={\"foo\": \"bar\"}\n    )\n    response = await client.send(request)\n    content = await response.json()\n    # httpbin returns query string we passed in the response\n    content.show(\"args\")\n\n\nasyncio.run(main())\n</code></pre> <pre><code>{\"foo\": \"bar\"}\n</code></pre></p> <p>You can also combine query string from params and hardcoded (params will override hardcoded)</p> <pre><code>request = reqsnaked.Request(\n\"GET\", \"https://httpbin.org/anything?fizz=bazz\",\nquery={\"foo\": \"bar\"}\n)\n</code></pre> Full code preview <p><pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"GET\", \"https://httpbin.org/anything?fizz=bazz\",\n        query={\"foo\": \"bar\"}\n    )\n    response = await client.send(request)\n    content = await response.json()\n    # httpbin returns query string we passed in the response\n    content.show(\"args\")\n\n\nasyncio.run(main())\n</code></pre> <pre><code>{\n\"fizz\": \"bazz\",\n\"foo\": \"bar\"\n}\n</code></pre></p> <p>It supports a few standart python types so params like this: <pre><code>query={\n    \"array\": [\"bar\", -123, False],\n    \"nothing\": None,\n    \"float\": 6.332,\n    \"boolean\": True\n}\n</code></pre></p> <p>Will produce such query string <pre><code>nothing=null&amp;boolean=1&amp;array=bar&amp;array=-123&amp;array=0&amp;float=6.332\n</code></pre></p>"},{"location":"user-guide/raw-response/","title":"Raw response","text":"<p>To access raw response, use <code>.read()</code> method on response. It returns a special object <code>reqsnaked.Bytes</code> and now it could only be converted to python's <code>bytes()</code> instance using <code>.as_bytes()</code>:</p> Read raw body<pre><code>client = reqsnaked.Client()\nrequest = reqsnaked.Request(\n    \"GET\", \"https://httpbin.org/bytes/10\",  # (1)\n)\nresponse = await client.send(request)\ndata = await response.read()\nprint(data.as_bytes())\n</code></pre> <ol> <li>This endpoint returns 10 random bytes</li> </ol> <pre><code>b'4NI\\xff\\x11\\x0b\\x82E\\xb3\\xa7'\n</code></pre> Full code preview <pre><code>import asyncio\n\nimport reqsnaked\n\n\nasync def main():\n    client = reqsnaked.Client()\n    request = reqsnaked.Request(\n        \"GET\", \"https://httpbin.org/bytes/10\",\n    )\n    response = await client.send(request)\n    data = await response.read()\n    print(data.as_bytes())\n\n\nasyncio.run(main())\n</code></pre> <p>Failure</p> <p>You cannot read from body twice</p>"}]}